(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,624509,e=>{"use strict";e.s([],430864),e.i(430864);var t=e.i(794702),n=e.i(911347),i=e.i(450323),r=e.i(823838),a=e.i(831095),o=e.i(675107),s=e.i(95767),c=e.i(383856),d=e.i(329096),h=e.i(206148),u=e.i(689862);function M(e){let t,g=new Map,l=e.features??{defaultConnected:!1},w=l.defaultConnected;return(0,u.createConnector)(u=>({id:"mock",name:"Mock Connector",type:M.type,async setup(){t=u.chains[0].id},async connect({chainId:e,withCapabilities:t}={}){if(l.connectError){if("boolean"==typeof l.connectError)throw new c.UserRejectedRequestError(Error("Failed to connect."));throw l.connectError}let n=await this.getProvider(),i=await n.request({method:"eth_requestAccounts"}),a=await this.getChainId();return e&&a!==e&&(a=(await this.switchChain({chainId:e})).id),w=!0,{accounts:t?i.map(e=>({address:(0,r.getAddress)(e),capabilities:{foo:{bar:e}}})):i.map(e=>(0,r.getAddress)(e)),chainId:a}},async disconnect(){w=!1},async getAccounts(){if(!w)throw new h.ConnectorNotConnectedError;let e=await this.getProvider();return(await e.request({method:"eth_accounts"})).map(e=>(0,r.getAddress)(e))},async getChainId(){let e=await this.getProvider(),t=await e.request({method:"eth_chainId"});return(0,i.fromHex)(t,"number")},async isAuthorized(){return!!l.reconnect&&!!w&&!!(await this.getAccounts()).length},async switchChain({chainId:e}){let t=await this.getProvider(),n=u.chains.find(t=>t.id===e);if(!n)throw new c.SwitchChainError(new h.ChainNotConfiguredError);return await t.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.numberToHex)(e)}]}),n},onAccountsChanged(e){0===e.length?this.onDisconnect():u.emitter.emit("change",{accounts:e.map(e=>(0,r.getAddress)(e))})},onChainChanged(e){let t=Number(e);u.emitter.emit("change",{chainId:t})},async onDisconnect(e){u.emitter.emit("disconnect"),w=!1},async getProvider({chainId:r}={}){let h=(u.chains.find(e=>e.id===r)??u.chains[0]).rpcUrls.default.http[0],M=async({method:n,params:r})=>{if("eth_chainId"===n)return(0,o.numberToHex)(t);if("eth_accounts"===n||"eth_requestAccounts"===n)return e.accounts;if("eth_signTypedData_v4"===n&&l.signTypedDataError){if("boolean"==typeof l.signTypedDataError)throw new c.UserRejectedRequestError(Error("Failed to sign typed data."));throw l.signTypedDataError}if("wallet_switchEthereumChain"===n){if(l.switchChainError){if("boolean"==typeof l.switchChainError)throw new c.UserRejectedRequestError(Error("Failed to switch chain."));throw l.switchChainError}t=(0,i.fromHex)(r[0].chainId,"number"),this.onChainChanged(t.toString());return}if("wallet_watchAsset"===n){if(l.watchAssetError){if("boolean"==typeof l.watchAssetError)throw new c.UserRejectedRequestError(Error("Failed to switch chain."));throw l.watchAssetError}return w}if("wallet_getCapabilities"===n)return{"0x2105":{paymasterService:{supported:"0x95132632579b073D12a6673e18Ab05777a6B86f8"===r[0]},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:"0x95132632579b073D12a6673e18Ab05777a6B86f8"===r[0]}}};if("wallet_sendCalls"===n){let e=[],t=r[0].calls,i=r[0].from;for(let a of t){let{result:t,error:o}=await d.rpc.http(h,{body:{method:"eth_sendTransaction",params:[{...a,...void 0!==i?{from:i}:{}}]}});if(o)throw new s.RpcRequestError({body:{method:n,params:r},error:o,url:h});e.push(t)}let c=(0,a.keccak256)((0,o.stringToHex)(JSON.stringify(t)));return g.set(c,e),{id:c}}if("wallet_getCallsStatus"===n){let e=g.get(r[0]);if(!e)return{atomic:!1,chainId:"0x1",id:r[0],status:100,receipts:[],version:"2.0.0"};let t=(await Promise.all(e.map(async e=>{let{result:t,error:i}=await d.rpc.http(h,{body:{method:"eth_getTransactionReceipt",params:[e],id:0}});if(i)throw new s.RpcRequestError({body:{method:n,params:r},error:i,url:h});return t?{blockHash:t.blockHash,blockNumber:t.blockNumber,gasUsed:t.gasUsed,logs:t.logs,status:t.status,transactionHash:t.transactionHash}:null}))).filter(e=>null!==e);return 0===t.length?{atomic:!1,chainId:"0x1",id:r[0],status:100,receipts:[],version:"2.0.0"}:{atomic:!1,chainId:"0x1",id:r[0],status:200,receipts:t,version:"2.0.0"}}if("wallet_showCallsStatus"===n)return;if("personal_sign"===n){if(l.signMessageError){if("boolean"==typeof l.signMessageError)throw new c.UserRejectedRequestError(Error("Failed to sign message."));throw l.signMessageError}n="eth_sign",r=[r[1],r[0]]}let u={method:n,params:r},{error:M,result:m}=await d.rpc.http(h,{body:u});if(M)throw new s.RpcRequestError({body:u,error:M,url:h});return m};return(0,n.custom)({request:M})({retryCount:0})}}))}function g(t={}){let n,i,a,s;return(0,u.createConnector)(d=>({id:"baseAccount",name:"Base Account",rdns:"app.base.account",type:"baseAccount",async connect({chainId:e,withCapabilities:t,...n}={}){try{let u=await this.getProvider(),M=e??d.chains[0]?.id;if(!M)throw new h.ChainNotConfiguredError;let{accounts:g,currentChainId:l}=await (async()=>{if(n.isReconnecting)return{accounts:(await u.request({method:"eth_accounts",params:[]})).map(e=>({address:(0,r.getAddress)(e)})),currentChainId:await this.getChainId()};let e=await u.request({method:"wallet_connect",params:[{capabilities:"capabilities"in n&&n.capabilities?n.capabilities:{},chainIds:[(0,o.numberToHex)(M),...d.chains.filter(e=>e.id!==M).map(e=>(0,o.numberToHex)(e.id))]}]});return{accounts:(await u.request({method:"eth_accounts"})).map(t=>e.accounts.find(e=>e.address===t)??{address:t}).map(e=>({address:(0,r.getAddress)(e.address),capabilities:e.capabilities??{}})),currentChainId:Number(e.chainIds[0])}})();if(i||(i=this.onAccountsChanged.bind(this),u.on("accountsChanged",i)),a||(a=this.onChainChanged.bind(this),u.on("chainChanged",a)),s||(s=this.onDisconnect.bind(this),u.on("disconnect",s)),e&&l!==e){let t=await this.switchChain({chainId:e}).catch(e=>{if(e.code===c.UserRejectedRequestError.code)throw e;return{id:l}});l=t?.id??l}return{accounts:t?g:g.map(e=>e.address),chainId:l}}catch(e){if(/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(e.message))throw new c.UserRejectedRequestError(e);throw e}},async disconnect(){let e=await this.getProvider();i&&(e.removeListener("accountsChanged",i),i=void 0),a&&(e.removeListener("chainChanged",a),a=void 0),s&&(e.removeListener("disconnect",s),s=void 0),e.disconnect()},async getAccounts(){let e=await this.getProvider();return(await e.request({method:"eth_accounts"})).map(e=>(0,r.getAddress)(e))},async getChainId(){let e=await this.getProvider();return Number(await e.request({method:"eth_chainId"}))},async getProvider(){if(!n){let i="string"==typeof t.preference?{options:t.preference}:{...t.preference,options:t.preference?.options??"all"},{createBaseAccountSDK:r}=await (()=>{try{return e.A(224814)}catch{throw Error('dependency "@base-org/account" not found')}})();n=r({...t,appChainIds:d.chains.map(e=>e.id),preference:i}).getProvider()}return n},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:t}){let n=d.chains.find(e=>e.id===t);if(!n)throw new c.SwitchChainError(new h.ChainNotConfiguredError);let i=await this.getProvider();try{return await i.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.numberToHex)(n.id)}]}),n}catch(r){if(4902===r.code)try{let r,a;r=e?.blockExplorerUrls?e.blockExplorerUrls:n.blockExplorers?.default.url?[n.blockExplorers?.default.url]:[],a=e?.rpcUrls?.length?e.rpcUrls:[n.rpcUrls.default?.http[0]??""];let s={blockExplorerUrls:r,chainId:(0,o.numberToHex)(t),chainName:e?.chainName??n.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??n.nativeCurrency,rpcUrls:a};return await i.request({method:"wallet_addEthereumChain",params:[s]}),n}catch(e){throw new c.UserRejectedRequestError(e)}throw new c.SwitchChainError(r)}},onAccountsChanged(e){0===e.length?this.onDisconnect():d.emitter.emit("change",{accounts:e.map(e=>(0,r.getAddress)(e))})},onChainChanged(e){let t=Number(e);d.emitter.emit("change",{chainId:t})},async onDisconnect(e){d.emitter.emit("disconnect");let t=await this.getProvider();i&&(t.removeListener("accountsChanged",i),i=void 0),a&&(t.removeListener("chainChanged",a),a=void 0),s&&(t.removeListener("disconnect",s),s=void 0)}}))}function l(e={}){let t,n,i,a;return(0,u.createConnector)(s=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",rdns:"com.coinbase.wallet",type:l.type,async connect({chainId:e,withCapabilities:t,...o}={}){try{let s=await this.getProvider(),d=(await s.request({method:"eth_requestAccounts",params:"instantOnboarding"in o&&o.instantOnboarding?[{onboarding:"instant"}]:[]})).map(e=>(0,r.getAddress)(e));n||(n=this.onAccountsChanged.bind(this),s.on("accountsChanged",n)),i||(i=this.onChainChanged.bind(this),s.on("chainChanged",i)),a||(a=this.onDisconnect.bind(this),s.on("disconnect",a));let h=await this.getChainId();if(e&&h!==e){let t=await this.switchChain({chainId:e}).catch(e=>{if(e.code===c.UserRejectedRequestError.code)throw e;return{id:h}});h=t?.id??h}return{accounts:t?d.map(e=>({address:e,capabilities:{}})):d,chainId:h}}catch(e){if(/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(e.message))throw new c.UserRejectedRequestError(e);throw e}},async disconnect(){let e=await this.getProvider();n&&(e.removeListener("accountsChanged",n),n=void 0),i&&(e.removeListener("chainChanged",i),i=void 0),a&&(e.removeListener("disconnect",a),a=void 0),e.disconnect(),e.close?.()},async getAccounts(){let e=await this.getProvider();return(await e.request({method:"eth_accounts"})).map(e=>(0,r.getAddress)(e))},async getChainId(){let e=await this.getProvider();return Number(await e.request({method:"eth_chainId"}))},async getProvider(){if(!t){let{createCoinbaseWalletSDK:n}=await (()=>{try{let e=Error("Cannot find module '@coinbase/wallet-sdk'");throw e.code="MODULE_NOT_FOUND",e}catch{throw Error('dependency "@coinbase/wallet-sdk" not found')}})();t=n({...e,appChainIds:s.chains.map(e=>e.id),preference:{options:"all",...e.preference??{}}}).getProvider()}return t},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:t}){let n=s.chains.find(e=>e.id===t);if(!n)throw new c.SwitchChainError(new h.ChainNotConfiguredError);let i=await this.getProvider();try{return await i.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.numberToHex)(n.id)}]}),n}catch(r){if(4902===r.code)try{let r,a;r=e?.blockExplorerUrls?e.blockExplorerUrls:n.blockExplorers?.default.url?[n.blockExplorers?.default.url]:[],a=e?.rpcUrls?.length?e.rpcUrls:[n.rpcUrls.default?.http[0]??""];let s={blockExplorerUrls:r,chainId:(0,o.numberToHex)(t),chainName:e?.chainName??n.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??n.nativeCurrency,rpcUrls:a};return await i.request({method:"wallet_addEthereumChain",params:[s]}),n}catch(e){throw new c.UserRejectedRequestError(e)}throw new c.SwitchChainError(r)}},onAccountsChanged(e){0===e.length?this.onDisconnect():s.emitter.emit("change",{accounts:e.map(e=>(0,r.getAddress)(e))})},onChainChanged(e){let t=Number(e);s.emitter.emit("change",{chainId:t})},async onDisconnect(e){s.emitter.emit("disconnect");let t=await this.getProvider();n&&(t.removeListener("accountsChanged",n),n=void 0),i&&(t.removeListener("chainChanged",i),i=void 0),a&&(t.removeListener("disconnect",a),a=void 0)}}))}function w(e={}){let t,n,i,a;return(0,u.createConnector)(s=>({id:"gemini",name:"Gemini Wallet",type:w.type,icon:"https://keys.gemini.com/images/gemini-wallet-logo.svg",async connect({chainId:e,withCapabilities:t}={}){try{let r=await this.getProvider(),o=await r.request({method:"eth_requestAccounts"});n||(n=this.onAccountsChanged.bind(this),r.on("accountsChanged",n)),i||(i=this.onChainChanged.bind(this),r.on("chainChanged",i)),a||(a=this.onDisconnect.bind(this),r.on("disconnect",a));let s=await this.getChainId();if(e&&s!==e){let t=await this.switchChain({chainId:e}).catch(e=>{if(e.code===c.UserRejectedRequestError.code)throw e;return{id:s}});s=t?.id??s}return{accounts:t?o.map(e=>({address:e,capabilities:{}})):o,chainId:s}}catch(e){if(/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(e.message))throw new c.UserRejectedRequestError(e);throw e}},async disconnect(){let e=await this.getProvider();n&&(e.removeListener("accountsChanged",n),n=void 0),i&&(e.removeListener("chainChanged",i),i=void 0),a&&(e.removeListener("disconnect",a),a=void 0),await e.disconnect()},async getAccounts(){let e=await this.getProvider();return(await e.request({method:"eth_accounts"})).map(e=>(0,r.getAddress)(e))},async getChainId(){let e=await this.getProvider();return Number(await e.request({method:"eth_chainId"}))},async getProvider(){if(!t){let{GeminiWalletProvider:n}=await (()=>{try{let e=Error("Cannot find module '@gemini-wallet/core'");throw e.code="MODULE_NOT_FOUND",e}catch{throw Error('dependency "@gemini-wallet/core" not found')}})();t=new n({appMetadata:e.appMetadata??{},chain:{id:s.chains[0]?.id??1,rpcUrl:s.chains[0]?.rpcUrls?.default?.http[0]}})}return t},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({chainId:e}){let t=s.chains.find(t=>t.id===e);if(!t)throw new c.SwitchChainError(new h.ChainNotConfiguredError);let n=await this.getProvider();try{return await n.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.numberToHex)(e)}]}),t}catch(e){throw new c.SwitchChainError(e)}},onAccountsChanged(e){0===e.length?this.onDisconnect():s.emitter.emit("change",{accounts:e.map(e=>(0,r.getAddress)(e))})},onChainChanged(e){let t=Number(e);s.emitter.emit("change",{chainId:t})},async onDisconnect(){s.emitter.emit("disconnect");let e=await this.getProvider();n&&(e.removeListener("accountsChanged",n),n=void 0),i&&(e.removeListener("chainChanged",i),i=void 0),a&&(e.removeListener("disconnect",a),a=void 0)}}))}function m(e){let{chain:t}=e,n=t.rpcUrls.default.http[0];if(!e.transports)return[n];let i=e.transports?.[t.id]?.({chain:t});return(i?.value?.transports||[i]).map(({value:e})=>e?.url||n)}M.type="mock",l.type="coinbaseWallet",w.type="gemini";var y=e.i(377349),I=e.i(204202),D=e.i(984534);function N(e={}){let t,n,a,s,d,M,g,l;return(0,u.createConnector)(u=>({id:"metaMaskSDK",name:"MetaMask",rdns:["io.metamask","io.metamask.mobile"],type:N.type,async setup(){let e=await this.getProvider();e?.on&&(M||(M=this.onConnect.bind(this),e.on("connect",M)),s||(s=this.onAccountsChanged.bind(this),e.on("accountsChanged",s)))},async connect({chainId:n,isReconnecting:i,withCapabilities:a}={}){let o=await this.getProvider();g||(g=this.onDisplayUri,o.on("display_uri",g));let h=[];i&&(h=await this.getAccounts().catch(()=>[]));try{let i,u;h?.length||(e.connectAndSign||e.connectWith?(e.connectAndSign?i=await t.connectAndSign({msg:e.connectAndSign}):e.connectWith&&(u=await t.connectWith({method:e.connectWith.method,params:e.connectWith.params})),h=await this.getAccounts()):h=(await t.connect()).map(e=>(0,r.getAddress)(e)));let w=await this.getChainId();if(n&&w!==n){let e=await this.switchChain({chainId:n}).catch(e=>{if(e.code===c.UserRejectedRequestError.code)throw e;return{id:w}});w=e?.id??w}return g&&(o.removeListener("display_uri",g),g=void 0),i?o.emit("connectAndSign",{accounts:h,chainId:w,signResponse:i}):u&&o.emit("connectWith",{accounts:h,chainId:w,connectWithResponse:u}),M&&(o.removeListener("connect",M),M=void 0),s||(s=this.onAccountsChanged.bind(this),o.on("accountsChanged",s)),d||(d=this.onChainChanged.bind(this),o.on("chainChanged",d)),l||(l=this.onDisconnect.bind(this),o.on("disconnect",l)),{accounts:a?h.map(e=>({address:e,capabilities:{}})):h,chainId:w}}catch(e){if(e.code===c.UserRejectedRequestError.code)throw new c.UserRejectedRequestError(e);if(e.code===c.ResourceUnavailableRpcError.code)throw new c.ResourceUnavailableRpcError(e);throw e}},async disconnect(){let e=await this.getProvider();d&&(e.removeListener("chainChanged",d),d=void 0),l&&(e.removeListener("disconnect",l),l=void 0),M||(M=this.onConnect.bind(this),e.on("connect",M)),await t.terminate()},async getAccounts(){let e=await this.getProvider();return(await e.request({method:"eth_accounts"})).map(e=>(0,r.getAddress)(e))},async getChainId(){let e=await this.getProvider();return Number(e.getChainId()||await e?.request({method:"eth_chainId"}))},async getProvider(){async function i(){let n=await (async()=>{let{default:e}=await (()=>{try{let e=Error("Cannot find module '@metamask/sdk'");throw e.code="MODULE_NOT_FOUND",e}catch{throw Error('dependency "@metamask/sdk" not found')}})();return"function"!=typeof e&&"function"==typeof e.default?e.default:e})(),i={};for(let e of u.chains)i[(0,o.numberToHex)(e.id)]=m({chain:e,transports:u.transports})?.[0];t=new n({...e,_source:"wagmi",forceDeleteProvider:!1,forceInjectProvider:!1,injectProvider:!1,readonlyRPCMap:i,dappMetadata:{...e.dappMetadata,name:e.dappMetadata?.name?e.dappMetadata?.name:"wagmi",url:e.dappMetadata?.url?e.dappMetadata?.url:"u">typeof window?window.location.origin:"https://wagmi.sh"},useDeeplink:!0});let r=await t.init(),a=r?.activeProvider?r.activeProvider:t.getProvider();if(!a)throw new y.ProviderNotFoundError;return a}return n||(a||(a=i()),n=await a),n},async isAuthorized(){try{return!!(await (0,I.withRetry)(()=>(0,D.withTimeout)(()=>this.getAccounts(),{timeout:200}),{delay:201,retryCount:3})).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:t}){let n=await this.getProvider(),r=u.chains.find(e=>e.id===t);if(!r)throw new c.SwitchChainError(new h.ChainNotConfiguredError);try{return await n.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.numberToHex)(t)}]}),await a(),await s(t),r}catch(i){if(i.code===c.UserRejectedRequestError.code)throw new c.UserRejectedRequestError(i);if(4902===i.code||i?.data?.originalError?.code===4902)try{return await n.request({method:"wallet_addEthereumChain",params:[{blockExplorerUrls:(()=>{let{default:t,...n}=r.blockExplorers??{};return e?.blockExplorerUrls?e.blockExplorerUrls:t?[t.url,...Object.values(n).map(e=>e.url)]:void 0})(),chainId:(0,o.numberToHex)(t),chainName:e?.chainName??r.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??r.nativeCurrency,rpcUrls:e?.rpcUrls?.length?e.rpcUrls:[r.rpcUrls.default?.http[0]??""]}]}),await a(),await s(t),r}catch(e){if(e.code===c.UserRejectedRequestError.code)throw new c.UserRejectedRequestError(e);throw new c.SwitchChainError(e)}throw new c.SwitchChainError(i)}async function a(){await (0,I.withRetry)(async()=>{let e=(0,i.hexToNumber)(await n.request({method:"eth_chainId"}));if(e!==t)throw Error("User rejected switch after adding network.");return e},{delay:50,retryCount:20})}async function s(e){await new Promise(t=>{let n=i=>{"chainId"in i&&i.chainId===e&&(u.emitter.off("change",n),t())};u.emitter.on("change",n),u.emitter.emit("change",{chainId:e})})}},async onAccountsChanged(e){if(0===e.length)if(!t.isExtensionActive())return;else this.onDisconnect();else if(u.emitter.listenerCount("connect")){let e=(await this.getChainId()).toString();this.onConnect({chainId:e})}else u.emitter.emit("change",{accounts:e.map(e=>(0,r.getAddress)(e))})},onChainChanged(e){let t=Number(e);u.emitter.emit("change",{chainId:t})},async onConnect(e){let t=await this.getAccounts();if(0===t.length)return;let n=Number(e.chainId);u.emitter.emit("connect",{accounts:t,chainId:n});let i=await this.getProvider();M&&(i.removeListener("connect",M),M=void 0),s||(s=this.onAccountsChanged.bind(this),i.on("accountsChanged",s)),d||(d=this.onChainChanged.bind(this),i.on("chainChanged",d)),l||(l=this.onDisconnect.bind(this),i.on("disconnect",l))},async onDisconnect(e){let t=await this.getProvider();e&&1013===e.code&&t&&(await this.getAccounts()).length||(u.emitter.emit("disconnect"),d&&(t.removeListener("chainChanged",d),d=void 0),l&&(t.removeListener("disconnect",l),l=void 0),M||(M=this.onConnect.bind(this),t.on("connect",M)))},onDisplayUri(e){u.emitter.emit("message",{type:"display_uri",data:e})}}))}function C(e={}){return(0,u.createConnector)(t=>{let n,i,a,s,d,u=t.chains??e.chains??[],M=t.transports?t.transports:e.transports;return{async connect({chainId:e=u[0].id,...t}={}){let n,r="isReconnecting"in t&&t.isReconnecting||!1,M="withCapabilities"in t&&t.withCapabilities||!1,g=[];if(r&&([g,n]=await Promise.all([this.getAccounts().catch(()=>[]),this.getChainId().catch(()=>void 0)]),e&&n!==e)){let t=await this.switchChain({chainId:e}).catch(e=>{if(e.code===c.UserRejectedRequestError.code)throw e;return{id:n}});n=t?.id??n}let l=await this.getProvider();try{if(!g?.length&&!r){let{RpcSchema:i}=await (()=>{try{let e=Error("Cannot find module 'porto'");throw e.code="MODULE_NOT_FOUND",e}catch{throw Error('dependency "porto" not found')}})(),{z:r}=await (()=>{try{let e=Error("Cannot find module 'porto/internal'");throw e.code="MODULE_NOT_FOUND",e}catch{throw Error('dependency "porto/internal" not found')}})(),a=await l.request({method:"wallet_connect",params:[{..."capabilities"in t?{capabilities:r.encode(i.wallet_connect.Capabilities,t.capabilities??{})}:{},chainIds:[(0,o.numberToHex)(e),...u.filter(t=>t.id!==e).map(e=>(0,o.numberToHex)(e.id))]}]});g=a.accounts,n=Number(a.chainIds[0])}if(!n)throw new h.ChainNotConfiguredError;return s&&(l.removeListener("connect",s),s=void 0),i||(i=this.onAccountsChanged.bind(this),l.on("accountsChanged",i)),a||(a=this.onChainChanged.bind(this),l.on("chainChanged",a)),d||(d=this.onDisconnect.bind(this),l.on("disconnect",d)),{accounts:g.map(e=>"object"==typeof e?M?e:e.address:M?{address:e,capabilities:{}}:e),chainId:n}}catch(e){if(e.code===c.UserRejectedRequestError.code)throw new c.UserRejectedRequestError(e);throw e}},async disconnect(){let e=await this.getProvider();a&&(e.removeListener("chainChanged",a),a=void 0),d&&(e.removeListener("disconnect",d),d=void 0),s||(s=this.onConnect.bind(this),e.on("connect",s)),await e.request({method:"wallet_disconnect"})},async getAccounts(){let e=await this.getProvider();return(await e.request({method:"eth_accounts"})).map(e=>(0,r.getAddress)(e))},async getChainId(){let e=await this.getProvider();return Number(await e.request({method:"eth_chainId"}))},getPortoInstance:async()=>(n??=(async()=>{let{Porto:t}=await (()=>{try{let e=Error("Cannot find module 'porto'");throw e.code="MODULE_NOT_FOUND",e}catch{throw Error('dependency "porto" not found')}})();return t.create({...e,announceProvider:!1,chains:u,transports:M})})(),await n),async getProvider(){return(await this.getPortoInstance()).provider},icon:"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K",id:"xyz.ithaca.porto",async isAuthorized(){try{return!!(await (0,I.withRetry)(()=>this.getAccounts())).length}catch{return!1}},name:"Porto",async onAccountsChanged(e){t.emitter.emit("change",{accounts:e.map(e=>(0,r.getAddress)(e))})},onChainChanged(e){let n=Number(e);t.emitter.emit("change",{chainId:n})},async onConnect(e){let n=await this.getAccounts();if(0===n.length)return;let r=Number(e.chainId);t.emitter.emit("connect",{accounts:n,chainId:r});let o=await this.getProvider();o&&(s&&(o.removeListener("connect",s),s=void 0),i||(i=this.onAccountsChanged.bind(this),o.on("accountsChanged",i)),a||(a=this.onChainChanged.bind(this),o.on("chainChanged",a)),d||(d=this.onDisconnect.bind(this),o.on("disconnect",d)))},async onDisconnect(e){let n=await this.getProvider();t.emitter.emit("disconnect"),n&&(a&&(n.removeListener("chainChanged",a),a=void 0),d&&(n.removeListener("disconnect",d),d=void 0),s||(s=this.onConnect.bind(this),n.on("connect",s)))},async setup(){if(!s){let e=await this.getProvider();s=this.onConnect.bind(this),e.on("connect",s)}},async switchChain({chainId:e}){let t=u.find(t=>t.id===e);if(!t)throw new c.SwitchChainError(new h.ChainNotConfiguredError);let n=await this.getProvider();return await n.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.numberToHex)(e)}]}),t},type:"injected"}})}function p(t={}){let n,i,{shimDisconnect:a=!1}=t;return(0,u.createConnector)(o=>({id:"safe",name:"Safe",type:p.type,async connect({withCapabilities:e}={}){let t=await this.getProvider();if(!t)throw new y.ProviderNotFoundError;let n=await this.getAccounts(),r=await this.getChainId();return i||(i=this.onDisconnect.bind(this),t.on("disconnect",i)),a&&await o.storage?.removeItem("safe.disconnected"),{accounts:e?n.map(e=>({address:e,capabilities:{}})):n,chainId:r}},async disconnect(){let e=await this.getProvider();if(!e)throw new y.ProviderNotFoundError;i&&(e.removeListener("disconnect",i),i=void 0),a&&await o.storage?.setItem("safe.disconnected",!0)},async getAccounts(){let e=await this.getProvider();if(!e)throw new y.ProviderNotFoundError;return(await e.request({method:"eth_accounts"})).map(r.getAddress)},async getProvider(){if("u">typeof window&&window?.parent!==window){if(!n){let{default:i}=await (()=>{try{return e.A(474683)}catch{throw Error('dependency "@safe-global/safe-apps-sdk" not found')}})(),r=new i(t),a=await (0,D.withTimeout)(()=>r.safe.getInfo(),{timeout:t.unstable_getInfoTimeout??10});if(!a)throw Error("Could not load Safe information");n=new(await (async()=>{let t=await (()=>{try{return e.A(381024)}catch{throw Error('dependency "@safe-global/safe-apps-provider" not found')}})();return"function"!=typeof t.SafeAppProvider&&"function"==typeof t.default.SafeAppProvider?t.default.SafeAppProvider:t.SafeAppProvider})())(a,r)}return n}},async getChainId(){let e=await this.getProvider();if(!e)throw new y.ProviderNotFoundError;return Number(e.chainId)},async isAuthorized(){try{if(a&&await o.storage?.getItem("safe.disconnected"))return!1;return!!(await this.getAccounts()).length}catch{return!1}},onAccountsChanged(){},onChainChanged(){},onDisconnect(){o.emitter.emit("disconnect")}}))}function j(e){let t,n,i,a,s,d,M,g,l=e.isNewChainsStale??!0;return(0,u.createConnector)(u=>({id:"walletConnect",name:"WalletConnect",type:j.type,async setup(){let e=await this.getProvider().catch(()=>null);e&&(s||(s=this.onConnect.bind(this),e.on("connect",s)),M||(M=this.onSessionDelete.bind(this),e.on("session_delete",M)))},async connect({chainId:e,withCapabilities:t,...n}={}){try{let o=await this.getProvider();if(!o)throw new y.ProviderNotFoundError;d||(d=this.onDisplayUri,o.on("display_uri",d));let h=e;if(!h){let e=await u.storage?.getItem("state")??{};h=u.chains.some(t=>t.id===e.chainId)?e.chainId:u.chains[0]?.id}if(!h)throw Error("No chains found on connector.");let l=await this.isChainsStale();if(o.session&&l&&await o.disconnect(),!o.session||l){let e=u.chains.filter(e=>e.id!==h).map(e=>e.id);await o.connect({optionalChains:[h,...e],..."pairingTopic"in n?{pairingTopic:n.pairingTopic}:{}}),this.setRequestedChainsIds(u.chains.map(e=>e.id))}let w=(await o.enable()).map(e=>(0,r.getAddress)(e)),m=await this.getChainId();if(e&&m!==e){let t=await this.switchChain({chainId:e}).catch(e=>{if(e.code===c.UserRejectedRequestError.code&&e.cause?.message!=="Missing or invalid. request() method: wallet_addEthereumChain")throw e;return{id:m}});m=t?.id??m}return d&&(o.removeListener("display_uri",d),d=void 0),s&&(o.removeListener("connect",s),s=void 0),i||(i=this.onAccountsChanged.bind(this),o.on("accountsChanged",i)),a||(a=this.onChainChanged.bind(this),o.on("chainChanged",a)),g||(g=this.onDisconnect.bind(this),o.on("disconnect",g)),M||(M=this.onSessionDelete.bind(this),o.on("session_delete",M)),{accounts:t?w.map(e=>({address:e,capabilities:{}})):w,chainId:m}}catch(e){if(/(user rejected|connection request reset)/i.test(e?.message))throw new c.UserRejectedRequestError(e);throw e}},async disconnect(){let e=await this.getProvider();try{await e?.disconnect()}catch(e){if(!/No matching key/i.test(e.message))throw e}finally{a&&(e?.removeListener("chainChanged",a),a=void 0),g&&(e?.removeListener("disconnect",g),g=void 0),s||(s=this.onConnect.bind(this),e?.on("connect",s)),i&&(e?.removeListener("accountsChanged",i),i=void 0),M&&(e?.removeListener("session_delete",M),M=void 0),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map(e=>(0,r.getAddress)(e))},async getProvider({chainId:i}={}){async function r(){let t=u.chains.map(e=>e.id);if(!t.length)return;let{EthereumProvider:n}=await (()=>{try{let e=Error("Cannot find module '@walletconnect/ethereum-provider'");throw e.code="MODULE_NOT_FOUND",e}catch{throw Error('dependency "@walletconnect/ethereum-provider" not found')}})();return await n.init({...e,disableProviderPing:!0,optionalChains:t,projectId:e.projectId,rpcMap:Object.fromEntries(u.chains.map(e=>{let[t]=m({chain:e,transports:u.transports});return[e.id,t]})),showQrModal:e.showQrModal??!0})}return t||(n||(n=r()),t=await n,t?.events.setMaxListeners(1/0)),i&&await this.switchChain?.({chainId:i}),t},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{let[e,t]=await Promise.all([this.getAccounts(),this.getProvider()]);if(!e.length)return!1;if(await this.isChainsStale()&&t.session)return await t.disconnect().catch(()=>{}),!1;return!0}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:t}){let n=await this.getProvider();if(!n)throw new y.ProviderNotFoundError;let i=u.chains.find(e=>e.id===t);if(!i)throw new c.SwitchChainError(new h.ChainNotConfiguredError);try{await Promise.all([new Promise(e=>{let n=({chainId:i})=>{i===t&&(u.emitter.off("change",n),e())};u.emitter.on("change",n)}),n.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,o.numberToHex)(t)}]})]);let e=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...e,t]),i}catch(r){if(/(user rejected)/i.test(r.message))throw new c.UserRejectedRequestError(r);try{let r,a;r=e?.blockExplorerUrls?e.blockExplorerUrls:i.blockExplorers?.default.url?[i.blockExplorers?.default.url]:[],a=e?.rpcUrls?.length?e.rpcUrls:[...i.rpcUrls.default.http];let s={blockExplorerUrls:r,chainId:(0,o.numberToHex)(t),chainName:e?.chainName??i.name,iconUrls:e?.iconUrls,nativeCurrency:e?.nativeCurrency??i.nativeCurrency,rpcUrls:a};await n.request({method:"wallet_addEthereumChain",params:[s]});let c=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...c,t]),i}catch(e){throw new c.UserRejectedRequestError(e)}}},onAccountsChanged(e){0===e.length?this.onDisconnect():u.emitter.emit("change",{accounts:e.map(e=>(0,r.getAddress)(e))})},onChainChanged(e){let t=Number(e);u.emitter.emit("change",{chainId:t})},async onConnect(e){let t=Number(e.chainId),n=await this.getAccounts();u.emitter.emit("connect",{accounts:n,chainId:t})},async onDisconnect(e){this.setRequestedChainsIds([]),u.emitter.emit("disconnect");let t=await this.getProvider();i&&(t.removeListener("accountsChanged",i),i=void 0),a&&(t.removeListener("chainChanged",a),a=void 0),g&&(t.removeListener("disconnect",g),g=void 0),M&&(t.removeListener("session_delete",M),M=void 0),s||(s=this.onConnect.bind(this),t.on("connect",s))},onDisplayUri(e){u.emitter.emit("message",{type:"display_uri",data:e})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds:()=>t?t.session?.namespaces.eip155?.accounts?.map(e=>Number.parseInt(e.split(":")[1]||"",10))??[]:[],async getRequestedChainsIds(){return await u.storage?.getItem(this.requestedChainsStorageKey)??[]},async isChainsStale(){if(!l)return!1;let e=u.chains.map(e=>e.id),t=this.getNamespaceChainsIds();if(t.length&&!t.some(t=>e.includes(t)))return!1;let n=await this.getRequestedChainsIds();return!e.every(e=>n.includes(e))},async setRequestedChainsIds(e){await u.storage?.setItem(this.requestedChainsStorageKey,e)},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}}))}N.type="metaMask",p.type="safe",j.type="walletConnect",e.s(["baseAccount",()=>g,"coinbaseWallet",()=>l,"gemini",()=>w,"injected",()=>t.injected,"metaMask",()=>N,"mock",()=>M,"porto",()=>C,"safe",()=>p,"version",0,"7.1.5","walletConnect",()=>j],624509)}]);