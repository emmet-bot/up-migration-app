(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,869609,e=>{"use strict";e.i(864380),e.s([])},47755,e=>{"use strict";var o=e.i(365801),t=e.i(742710),n=e.i(675457),r=e.i(401564),a=e.i(979484),i=e.i(518887),s=e.i(564126),c=e.i(360334),l=e.i(227302),u=e.i(664717);let d={getGasPriceInEther:(e,o)=>Number(o*e)/1e18,getGasPriceInUSD(e,o,t){let r=d.getGasPriceInEther(o,t);return n.NumberUtil.bigNumber(e).times(r).toNumber()},getPriceImpact({sourceTokenAmount:e,sourceTokenPriceInUSD:o,toTokenPriceInUSD:t,toTokenAmount:r}){let a=n.NumberUtil.bigNumber(e).times(o),i=n.NumberUtil.bigNumber(r).times(t);return a.minus(i).div(a).times(100).toNumber()},getMaxSlippage(e,o){let t=n.NumberUtil.bigNumber(e).div(100);return n.NumberUtil.multiply(o,t).toNumber()},getProviderFee:(e,o=.0085)=>n.NumberUtil.bigNumber(e).times(o).toString(),isInsufficientNetworkTokenForGas:(e,o)=>!!n.NumberUtil.bigNumber(e).eq(0)||n.NumberUtil.bigNumber(n.NumberUtil.bigNumber(o||"0")).gt(e),isInsufficientSourceTokenForSwap(e,o,t){let r=t?.find(e=>e.address===o)?.quantity?.numeric;return n.NumberUtil.bigNumber(r||"0").lt(e)}};var T=e.i(592279),k=e.i(851887),m=e.i(24742),p=e.i(960398),g=e.i(971080),w=e.i(149454),A=e.i(653157),S=e.i(221728),C=e.i(811424);let P={initializing:!1,initialized:!1,loadingPrices:!1,loadingQuote:!1,loadingApprovalTransaction:!1,loadingBuildTransaction:!1,loadingTransaction:!1,switchingTokens:!1,fetchError:!1,approvalTransaction:void 0,swapTransaction:void 0,transactionError:void 0,sourceToken:void 0,sourceTokenAmount:"",sourceTokenPriceInUSD:0,toToken:void 0,toTokenAmount:"",toTokenPriceInUSD:0,networkPrice:"0",networkBalanceInUSD:"0",networkTokenSymbol:"",inputError:void 0,slippage:c.ConstantsUtil.CONVERT_SLIPPAGE_TOLERANCE,tokens:void 0,popularTokens:void 0,suggestedTokens:void 0,foundTokens:void 0,myTokensWithBalance:void 0,tokensPriceMap:{},gasFee:"0",gasPriceInUSD:0,priceImpact:void 0,maxSlippage:void 0,providerFee:void 0},b=(0,o.proxy)({...P}),h={state:b,subscribe:e=>(0,o.subscribe)(b,()=>e(b)),subscribeKey:(e,o)=>(0,t.subscribeKey)(b,e,o),getParams(){let e=p.ChainController.state.activeChain,o=p.ChainController.getAccountData(e)?.caipAddress??p.ChainController.state.activeCaipAddress,t=l.CoreHelperUtil.getPlainAddress(o),a=(0,s.getActiveNetworkTokenAddress)(),i=w.ConnectorController.getConnectorId(p.ChainController.state.activeChain);if(!t)throw Error("No address found to swap the tokens from.");let c=!b.toToken?.address||!b.toToken?.decimals,u=!b.sourceToken?.address||!b.sourceToken?.decimals||!n.NumberUtil.bigNumber(b.sourceTokenAmount).gt(0),d=!b.sourceTokenAmount;return{networkAddress:a,fromAddress:t,fromCaipAddress:o,sourceTokenAddress:b.sourceToken?.address,toTokenAddress:b.toToken?.address,toTokenAmount:b.toTokenAmount,toTokenDecimals:b.toToken?.decimals,sourceTokenAmount:b.sourceTokenAmount,sourceTokenDecimals:b.sourceToken?.decimals,invalidToToken:c,invalidSourceToken:u,invalidSourceTokenAmount:d,availableToSwap:o&&!c&&!u&&!d,isAuthConnector:i===r.ConstantsUtil.CONNECTOR_ID.AUTH}},async setSourceToken(e){if(!e){b.sourceToken=e,b.sourceTokenAmount="",b.sourceTokenPriceInUSD=0;return}b.sourceToken=e,await v.setTokenPrice(e.address,"sourceToken")},setSourceTokenAmount(e){b.sourceTokenAmount=e},async setToToken(e){if(!e){b.toToken=e,b.toTokenAmount="",b.toTokenPriceInUSD=0;return}b.toToken=e,await v.setTokenPrice(e.address,"toToken")},setToTokenAmount(e){b.toTokenAmount=e?n.NumberUtil.toFixed(e,6):""},async setTokenPrice(e,o){let t=b.tokensPriceMap[e]||0;t||(b.loadingPrices=!0,t=await v.getAddressPrice(e)),"sourceToken"===o?b.sourceTokenPriceInUSD=t:"toToken"===o&&(b.toTokenPriceInUSD=t),b.loadingPrices&&(b.loadingPrices=!1),v.getParams().availableToSwap&&!b.switchingTokens&&v.swapTokens()},async switchTokens(){if(!b.initializing&&b.initialized&&!b.switchingTokens){b.switchingTokens=!0;try{let e=b.toToken?{...b.toToken}:void 0,o=b.sourceToken?{...b.sourceToken}:void 0,t=e&&""===b.toTokenAmount?"1":b.toTokenAmount;v.setSourceTokenAmount(t),v.setToTokenAmount(""),await v.setSourceToken(e),await v.setToToken(o),b.switchingTokens=!1,v.swapTokens()}catch(e){throw b.switchingTokens=!1,e}}},resetState(){b.myTokensWithBalance=P.myTokensWithBalance,b.tokensPriceMap=P.tokensPriceMap,b.initialized=P.initialized,b.initializing=P.initializing,b.switchingTokens=P.switchingTokens,b.sourceToken=P.sourceToken,b.sourceTokenAmount=P.sourceTokenAmount,b.sourceTokenPriceInUSD=P.sourceTokenPriceInUSD,b.toToken=P.toToken,b.toTokenAmount=P.toTokenAmount,b.toTokenPriceInUSD=P.toTokenPriceInUSD,b.networkPrice=P.networkPrice,b.networkTokenSymbol=P.networkTokenSymbol,b.networkBalanceInUSD=P.networkBalanceInUSD,b.inputError=P.inputError},resetValues(){let{networkAddress:e}=v.getParams(),o=b.tokens?.find(o=>o.address===e);v.setSourceToken(o),v.setToToken(void 0)},getApprovalLoadingState:()=>b.loadingApprovalTransaction,clearError(){b.transactionError=void 0},async initializeState(){if(!b.initializing){if(b.initializing=!0,!b.initialized)try{await v.fetchTokens(),b.initialized=!0}catch(e){b.initialized=!1,C.SnackController.showError("Failed to initialize swap"),S.RouterController.goBack()}b.initializing=!1}},async fetchTokens(){let{networkAddress:e}=v.getParams();await v.getNetworkTokenPrice(),await v.getMyTokensWithBalance();let o=b.myTokensWithBalance?.find(o=>o.address===e);o&&(b.networkTokenSymbol=o.symbol,v.setSourceToken(o),v.setSourceTokenAmount("0"))},async getTokenList(){let e=p.ChainController.state.activeCaipNetwork?.caipNetworkId;if(b.caipNetworkId!==e||!b.tokens)try{b.tokensLoading=!0;let o=await u.SwapApiUtil.getTokenList(e);b.tokens=o,b.caipNetworkId=e,b.popularTokens=o.sort((e,o)=>e.symbol<o.symbol?-1:+(e.symbol>o.symbol));let t=(e&&c.ConstantsUtil.SUGGESTED_TOKENS_BY_CHAIN?.[e]||[]).map(e=>o.find(o=>o.symbol===e)).filter(e=>!!e),n=(c.ConstantsUtil.SWAP_SUGGESTED_TOKENS||[]).map(e=>o.find(o=>o.symbol===e)).filter(e=>!!e).filter(e=>!t.some(o=>o.address===e.address));b.suggestedTokens=[...t,...n]}catch(e){b.tokens=[],b.popularTokens=[],b.suggestedTokens=[]}finally{b.tokensLoading=!1}},async getAddressPrice(e){let o=b.tokensPriceMap[e];if(o)return o;let t=await m.BlockchainApiController.fetchTokenPrice({addresses:[e]}),n=t?.fungibles||[],r=[...b.tokens||[],...b.myTokensWithBalance||[]],a=r?.find(o=>o.address===e)?.symbol,i=parseFloat((n.find(e=>e.symbol.toLowerCase()===a?.toLowerCase())?.price||0).toString());return b.tokensPriceMap[e]=i,i},async getNetworkTokenPrice(){let{networkAddress:e}=v.getParams(),o=await m.BlockchainApiController.fetchTokenPrice({addresses:[e]}).catch(()=>(C.SnackController.showError("Failed to fetch network token price"),{fungibles:[]})),t=o.fungibles?.[0],n=t?.price.toString()||"0";b.tokensPriceMap[e]=parseFloat(n),b.networkTokenSymbol=t?.symbol||"",b.networkPrice=n},async getMyTokensWithBalance(e){let o=await i.BalanceUtil.getMyTokensWithBalance({forceUpdate:e,caipNetwork:p.ChainController.state.activeCaipNetwork,address:p.ChainController.getAccountData()?.address}),t=u.SwapApiUtil.mapBalancesToSwapTokens(o);t&&(await v.getInitialGasPrice(),v.setBalances(t))},setBalances(e){let{networkAddress:o}=v.getParams(),t=p.ChainController.state.activeCaipNetwork;if(!t)return;let r=e.find(e=>e.address===o);e.forEach(e=>{b.tokensPriceMap[e.address]=e.price||0}),b.myTokensWithBalance=e.filter(e=>e.address.startsWith(t.caipNetworkId)),b.networkBalanceInUSD=r?n.NumberUtil.multiply(r.quantity.numeric,r.price).toString():"0"},async getInitialGasPrice(){let e=await u.SwapApiUtil.fetchGasPrice();if(!e)return{gasPrice:null,gasPriceInUSD:null};switch(p.ChainController.state?.activeCaipNetwork?.chainNamespace){case r.ConstantsUtil.CHAIN.SOLANA:return b.gasFee=e.standard??"0",b.gasPriceInUSD=n.NumberUtil.multiply(e.standard,b.networkPrice).div(1e9).toNumber(),{gasPrice:BigInt(b.gasFee),gasPriceInUSD:Number(b.gasPriceInUSD)};case r.ConstantsUtil.CHAIN.EVM:default:let o=e.standard??"0",t=BigInt(o),a=BigInt(15e4),i=d.getGasPriceInUSD(b.networkPrice,a,t);return b.gasFee=o,b.gasPriceInUSD=i,{gasPrice:t,gasPriceInUSD:i}}},async swapTokens(){let e=p.ChainController.getAccountData()?.address,o=b.sourceToken,t=b.toToken,r=n.NumberUtil.bigNumber(b.sourceTokenAmount).gt(0);if(r||v.setToTokenAmount(""),!t||!o||b.loadingPrices||!r||!e)return;b.loadingQuote=!0;let a=n.NumberUtil.bigNumber(b.sourceTokenAmount).times(10**o.decimals).round(0).toFixed(0);try{let r=await m.BlockchainApiController.fetchSwapQuote({userAddress:e,from:o.address,to:t.address,gasPrice:b.gasFee,amount:a.toString()});b.loadingQuote=!1;let i=r?.quotes?.[0]?.toAmount;if(!i)return void k.AlertController.open({displayMessage:"Incorrect amount",debugMessage:"Please enter a valid amount"},"error");let s=n.NumberUtil.bigNumber(i).div(10**t.decimals).toString();v.setToTokenAmount(s),v.hasInsufficientToken(b.sourceTokenAmount,o.address)?b.inputError="Insufficient balance":(b.inputError=void 0,v.setTransactionDetails())}catch(o){let e=await u.SwapApiUtil.handleSwapError(o);b.loadingQuote=!1,b.inputError=e||"Insufficient balance"}},async getTransaction(){let{fromCaipAddress:e,availableToSwap:o}=v.getParams(),t=b.sourceToken,n=b.toToken;if(e&&o&&t&&n&&!b.loadingQuote)try{let o;return b.loadingBuildTransaction=!0,o=await u.SwapApiUtil.fetchSwapAllowance({userAddress:e,tokenAddress:t.address,sourceTokenAmount:b.sourceTokenAmount,sourceTokenDecimals:t.decimals})?await v.createSwapTransaction():await v.createAllowanceTransaction(),b.loadingBuildTransaction=!1,b.fetchError=!1,o}catch(e){S.RouterController.goBack(),C.SnackController.showError("Failed to check allowance"),b.loadingBuildTransaction=!1,b.approvalTransaction=void 0,b.swapTransaction=void 0,b.fetchError=!0;return}},async createAllowanceTransaction(){let{fromCaipAddress:e,sourceTokenAddress:o,toTokenAddress:t}=v.getParams();if(e&&t){if(!o)throw Error("createAllowanceTransaction - No source token address found.");try{let n=await m.BlockchainApiController.generateApproveCalldata({from:o,to:t,userAddress:e}),r=l.CoreHelperUtil.getPlainAddress(n.tx.from);if(!r)throw Error("SwapController:createAllowanceTransaction - address is required");let a={data:n.tx.data,to:r,gasPrice:BigInt(n.tx.eip155.gasPrice),value:BigInt(n.tx.value),toAmount:b.toTokenAmount};return b.swapTransaction=void 0,b.approvalTransaction={data:a.data,to:a.to,gasPrice:a.gasPrice,value:a.value,toAmount:a.toAmount},{data:a.data,to:a.to,gasPrice:a.gasPrice,value:a.value,toAmount:a.toAmount}}catch(e){S.RouterController.goBack(),C.SnackController.showError("Failed to create approval transaction"),b.approvalTransaction=void 0,b.swapTransaction=void 0,b.fetchError=!0;return}}},async createSwapTransaction(){let{networkAddress:e,fromCaipAddress:o,sourceTokenAmount:t}=v.getParams(),n=b.sourceToken,r=b.toToken;if(!o||!t||!n||!r)return;let a=g.ConnectionController.parseUnits(t,n.decimals)?.toString();try{let t=await m.BlockchainApiController.generateSwapCalldata({userAddress:o,from:n.address,to:r.address,amount:a,disableEstimate:!0}),i=n.address===e,s=BigInt(t.tx.eip155.gas),c=BigInt(t.tx.eip155.gasPrice),u=l.CoreHelperUtil.getPlainAddress(t.tx.to);if(!u)throw Error("SwapController:createSwapTransaction - address is required");let T={data:t.tx.data,to:u,gas:s,gasPrice:c,value:i?BigInt(a??"0"):BigInt("0"),toAmount:b.toTokenAmount};return b.gasPriceInUSD=d.getGasPriceInUSD(b.networkPrice,s,c),b.approvalTransaction=void 0,b.swapTransaction=T,T}catch(e){S.RouterController.goBack(),C.SnackController.showError("Failed to create transaction"),b.approvalTransaction=void 0,b.swapTransaction=void 0,b.fetchError=!0;return}},onEmbeddedWalletApprovalSuccess(){C.SnackController.showLoading("Approve limit increase in your wallet"),S.RouterController.replace("SwapPreview")},async sendTransactionForApproval(e){let{fromAddress:o,isAuthConnector:t}=v.getParams();b.loadingApprovalTransaction=!0,t?S.RouterController.pushTransactionStack({onSuccess:v.onEmbeddedWalletApprovalSuccess}):C.SnackController.showLoading("Approve limit increase in your wallet");try{await g.ConnectionController.sendTransaction({address:o,to:e.to,data:e.data,value:e.value,chainNamespace:r.ConstantsUtil.CHAIN.EVM}),await v.swapTokens(),await v.getTransaction(),b.approvalTransaction=void 0,b.loadingApprovalTransaction=!1}catch(e){b.transactionError=e?.displayMessage,b.loadingApprovalTransaction=!1,C.SnackController.showError(e?.displayMessage||"Transaction error"),A.EventsController.sendEvent({type:"track",event:"SWAP_APPROVAL_ERROR",properties:{message:e?.displayMessage||e?.message||"Unknown",network:p.ChainController.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:v.state.sourceToken?.symbol||"",swapToToken:v.state.toToken?.symbol||"",swapFromAmount:v.state.sourceTokenAmount||"",swapToAmount:v.state.toTokenAmount||"",isSmartAccount:(0,s.getPreferredAccountType)(r.ConstantsUtil.CHAIN.EVM)===a.W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT}})}},async sendTransactionForSwap(e){if(!e)return;let{fromAddress:o,toTokenAmount:t,isAuthConnector:i}=v.getParams();b.loadingTransaction=!0;let c=`Swapping ${b.sourceToken?.symbol} to ${n.NumberUtil.formatNumberToLocalString(t,3)} ${b.toToken?.symbol}`,l=`Swapped ${b.sourceToken?.symbol} to ${n.NumberUtil.formatNumberToLocalString(t,3)} ${b.toToken?.symbol}`;i?S.RouterController.pushTransactionStack({onSuccess(){S.RouterController.replace("Account"),C.SnackController.showLoading(c),h.resetState()}}):C.SnackController.showLoading("Confirm transaction in your wallet");try{let t=[b.sourceToken?.address,b.toToken?.address].join(","),n=await g.ConnectionController.sendTransaction({address:o,to:e.to,data:e.data,value:e.value,chainNamespace:r.ConstantsUtil.CHAIN.EVM});return b.loadingTransaction=!1,C.SnackController.showSuccess(l),A.EventsController.sendEvent({type:"track",event:"SWAP_SUCCESS",properties:{network:p.ChainController.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:v.state.sourceToken?.symbol||"",swapToToken:v.state.toToken?.symbol||"",swapFromAmount:v.state.sourceTokenAmount||"",swapToAmount:v.state.toTokenAmount||"",isSmartAccount:(0,s.getPreferredAccountType)(r.ConstantsUtil.CHAIN.EVM)===a.W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT}}),h.resetState(),i||S.RouterController.replace("Account"),h.getMyTokensWithBalance(t),n}catch(e){b.transactionError=e?.displayMessage,b.loadingTransaction=!1,C.SnackController.showError(e?.displayMessage||"Transaction error"),A.EventsController.sendEvent({type:"track",event:"SWAP_ERROR",properties:{message:e?.displayMessage||e?.message||"Unknown",network:p.ChainController.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:v.state.sourceToken?.symbol||"",swapToToken:v.state.toToken?.symbol||"",swapFromAmount:v.state.sourceTokenAmount||"",swapToAmount:v.state.toTokenAmount||"",isSmartAccount:(0,s.getPreferredAccountType)(r.ConstantsUtil.CHAIN.EVM)===a.W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT}});return}},hasInsufficientToken:(e,o)=>d.isInsufficientSourceTokenForSwap(e,o,b.myTokensWithBalance),setTransactionDetails(){let{toTokenAddress:e,toTokenDecimals:o}=v.getParams();e&&o&&(b.gasPriceInUSD=d.getGasPriceInUSD(b.networkPrice,BigInt(b.gasFee),BigInt(15e4)),b.priceImpact=d.getPriceImpact({sourceTokenAmount:b.sourceTokenAmount,sourceTokenPriceInUSD:b.sourceTokenPriceInUSD,toTokenPriceInUSD:b.toTokenPriceInUSD,toTokenAmount:b.toTokenAmount}),b.maxSlippage=d.getMaxSlippage(b.slippage,b.toTokenAmount),b.providerFee=d.getProviderFee(b.sourceTokenAmount))}},v=(0,T.withErrorBoundary)(h);e.s(["SwapController",0,v],47755)}]);